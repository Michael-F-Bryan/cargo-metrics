<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Counting Lines of Unsafe - An Unofficial Guide to Using Rustc</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./compilation_process.html"><strong>2.</strong> The Compilation Process</a></li><li><a href="./rustc_driver.html"><strong>3.</strong> Instrumenting rustc_driver</a></li><li><a href="./unsafe_count.html" class="active"><strong>4.</strong> Counting Lines of Unsafe</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">An Unofficial Guide to Using Rustc</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./unsafe_count.html#counting-lines-of-unsafe" id="counting-lines-of-unsafe"><h1>Counting Lines of Unsafe</h1></a>
<p>The first metric we're going to calculate is the number of lines of unsafe
in a crate. For this we don't need to run any of the later steps like type
checking or <code>borrowck</code>, so we'll just use the AST generated after the compiler
finishes parsing. We can use the <a href="https://github.com/rust-lang/rust/blob/e3245948445b77c25cd9f3b29cbad3187aee3eb7/src/librustc_driver/driver.rs#L324"><code>CompileController.after_parse</code></a> to
hook in after the compiler has finished parsing and expanding macros.</p>
<p>For the actual AST inspection, the <code>syntax</code> crate provides an extremely handy
<a href="https://michael-f-bryan.github.io/rustc-internal-docs/syntax/visit/trait.Visitor.html">Visitor</a> trait which will recursively visit each node in a <a href="https://michael-f-bryan.github.io/rustc-internal-docs/syntax/ast/struct.Crate.html">Crate</a>. So
that means creating an unsafe code counter will require:</p>
<ul>
<li>Creating a type which implements the <a href="https://michael-f-bryan.github.io/rustc-internal-docs/syntax/visit/trait.Visitor.html">Visitor</a> trait, overriding just the
methods which inspect <code>Block</code>s and <code>Item</code>s</li>
<li>In the <code>Visitor</code> impl store the <a href="https://michael-f-bryan.github.io/rustc-internal-docs/syntax/ext/quote/rt/struct.Span.html">Span</a> for all <code>unsafe</code> blocks we find</li>
<li>Set the <code>controller.after_parse.callback</code> to be a closure which invokes our
custom <code>Visitor</code>, making sure the result gets saved back in our <code>Calls</code>
struct</li>
<li>In the top level <code>main()</code> function, print out the results of our <code>unsafe</code>
analysis</li>
</ul>
<p>First, we'll create the custom <code>Visitor</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(rustc_private)]
# extern crate syntax;
use syntax::ast::{Block, BlockCheckMode, Item, ItemKind, Unsafety};
use syntax::visit::{self, Visitor};
use syntax::ext::quote::rt::Span;

pub struct UnsafeVisitor {
    unsafe_lines: Vec&lt;Span&gt;,
}

impl&lt;'a&gt; Visitor&lt;'a&gt; for UnsafeVisitor {
    fn visit_item(&amp;mut self, item: &amp;'a Item) {
        match item.node {
            ItemKind::Fn(_, Unsafety::Unsafe, ..) |
            ItemKind::Trait(Unsafety::Unsafe, ..) | 
            ItemKind::DefaultImpl(Unsafety::Unsafe, ..) | 
            ItemKind::Impl(Unsafety::Unsafe, ..) =&gt; {
                self.unsafe_lines.push(item.span.clone());
            }
            _ =&gt; {},
        }

        visit::walk_item(self, item);
    }

    fn visit_block(&amp;mut self, block: &amp;'a Block) {
        if let BlockCheckMode::Unsafe(_) = block.rules {
            self.unsafe_lines.push(block.span.clone());
        }

        visit::walk_block(self, block);
    }
}
# fn main() {}
</code></pre></pre>
<p>It took a while to skim through all the docs for <a href="https://michael-f-bryan.github.io/rustc-internal-docs/syntax/ast/struct.Item.html">Item</a> and <a href="https://michael-f-bryan.github.io/rustc-internal-docs/syntax/ast/struct.Block.html">Block</a> to
figure out how you can tell when something is <code>unsafe</code>, but that's more tedious
than difficult. For now we're going to assume you'll never get an unsafe block
inside a function which is also defined as unsafe.</p>
<p>Next, let's define a couple data structures to store our metrics in. They're
pretty boring as-is, just a couple <em>Plain Ol' Data</em> structs.</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug, Clone, Default)]
pub struct Metrics {
    pub spans: Vec&lt;Row&gt;,
    pub total_lines: usize,
}

#[derive(Debug, Clone, Default)]
pub struct Row {
    pub start: Location,
    pub end: Location,
    pub num_lines: usize,
}

#[derive(Debug, Clone, Default)]
pub struct Location {
    pub filename: String,
    pub line: usize,
    pub col: usize,
}
# fn main() {}
</code></pre></pre>
<p>To make things easier, I've pulled the calling of <code>UnsafeVisitor</code> and resolving
all <code>Spans</code> into line numbers and file locations into a helper function called
<code>analyse_ast</code> which takes the AST and a <code>CodeMap</code> and transforms it into a
<code>Metrics</code>.</p>
<p>The easiest way to return information from the internals of <code>rustc</code> to our top
level is by updating the internal state of our <code>Calls</code> to hold the data to be
returned. Because the trait definition for <code>CompilerCalls</code> doesn't ensure our
<code>Calls</code> will outlive the running of <code>rustc_driver</code>, we need to use a
<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> to satisfy the borrow checker at runtime instead. To do things
properly, <code>Calls</code> will contain a <code>Rc&lt;RefCell&lt;Option&lt;Metrics&gt;&gt;&gt;</code>. The type
definition looks quite intimidating, but basically it signifies that we'll only
have metrics after the compiler has run, and we wrap it in a <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>
so it can be mutated by multiple entities (in this case, both <code>rustc</code> and us).</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(rustc_private)]
# #![feature(box_syntax)]
# extern crate rustc;
# extern crate rustc_driver;
# extern crate getopts;
# extern crate syntax;
# use syntax::ast::Crate;
# use syntax::codemap::CodeMap;
# use rustc::session::Session;
# use rustc_driver::driver::{CompileController, CompileState};
# use rustc_driver::{CompilerCalls, Compilation};
# use std::rc::Rc;
# use std::cell::RefCell;
# #[derive(Debug, Clone, Default)]
# pub struct Metrics;
# fn analyse_ast(_ast: &amp;Crate, _codemap: &amp;CodeMap) -&gt; Metrics {unimplemented!()}
#[derive(Default, Debug, Clone)]
pub struct Calls {
    pub unsafe_metrics: Rc&lt;RefCell&lt;Option&lt;Metrics&gt;&gt;&gt;,
}

impl&lt;'a&gt; CompilerCalls&lt;'a&gt; for Calls {
    fn build_controller(&amp;mut self, 
                        _: &amp;Session, 
                        _: &amp;getopts::Matches) -&gt; CompileController&lt;'a&gt; {
        let mut controller = CompileController::basic();
        controller.after_parse.stop = Compilation::Stop;

        let metrics = self.unsafe_metrics.clone();

        controller.after_parse.callback = box move |compile_state: &amp;mut CompileState| {
            let ast = compile_state.krate.as_ref().unwrap();

            *metrics.borrow_mut() = Some(analyse_ast(
                ast,
                compile_state.session.codemap(),
            ));
        };

        controller
    }
}
# fn main() {}
</code></pre></pre>
<p>You can see that after the AST has been analysed we set <code>metrics</code> (a pointer
to the <code>unsafe_metrics</code> property inside <code>Calls</code>) to be the result of the
analysis.</p>
<p>The helper function itself, <code>analyse_ast()</code>, then just creates a visitor,
makes it visit the provided AST, then turns the result into a <code>Metrics</code> for
our analyser.</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(rustc_private)]
# #![allow(dead_code)]
# extern crate syntax;
# extern crate syntax_pos;
# use syntax::codemap::CodeMap;
# use syntax::ast::Crate;
# use syntax::ext::quote::rt::Span;
# use syntax_pos::Loc;
# use syntax::visit::{self, Visitor};
fn analyse_ast(ast: &amp;Crate, codemap: &amp;CodeMap) -&gt; Metrics {
    let mut visitor = UnsafeVisitor::new();

    // analyse the crate
    visit::walk_crate(&amp;mut visitor, ast);

    // then resolve spans to line numbers and locations
    let spans = visitor
        .unsafe_lines
        .iter()
        .map(|span| {
            let start = Location::from(codemap.lookup_char_pos(span.lo));
            let end = Location::from(codemap.lookup_char_pos(span.hi));
            let diff = end.line - start.line;

            Row {
                start: start,
                end: end,
                num_lines: if diff == 0 { 1 } else { diff },
            }
        })
        .collect();

    Metrics {
        spans: spans,
        total_lines: codemap.count_lines(),
    }
}
# fn main() {}
# #[derive(Default, Debug)]
# struct UnsafeVisitor { unsafe_lines: Vec&lt;Span&gt; }
# impl&lt;'a&gt; Visitor&lt;'a&gt; for UnsafeVisitor {}
# impl UnsafeVisitor { fn new() -&gt; UnsafeVisitor { UnsafeVisitor::default() }}
# struct Metrics { spans: Vec&lt;Row&gt;, total_lines: usize }
# struct Row { start: Location, end: Location, num_lines: usize }
# struct Location { line: usize }
# impl From&lt;Loc&gt; for Location { fn from(_other: Loc) -&gt; Self { unimplemented!() } }
</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="./rustc_driver.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                

            </div>

            
                <a href="./rustc_driver.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
